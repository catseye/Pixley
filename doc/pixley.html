<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/2002/REC-xhtml1-20020801/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
<title>The Pixley Programming Language</title>
  <!-- begin html doc dynamic markup -->
  <script type="text/javascript" src="/contrib/jquery-1.6.4.min.js"></script>
  <script type="text/javascript" src="/scripts/documentation.js"></script>
  <!-- end html doc dynamic markup -->
</head>
<body>

<h1>The Pixley Programming Language</h1>

<p>Language version 2.0, distribution revision 2011.1209</p>

<h2>Introduction</h2>

<p><dfn>Pixley</dfn> is a strict and purely functional subset of R<sup>5</sup>RS Scheme.
All Pixley programs are also therefore Scheme programs.</p>

<p>Pixley was designed for "bootstrappability".  I aimed to encompass a
minimal subset of Scheme that was still expressive enough to
permit writing a Pixley interpreter without too much pain.</p>

<h2>Semantics</h2>

<p>Pixley implements the following functions and forms from Scheme
(listed in alphabetical order):</p>

<ul>
<li><code>car</code></li>
<li><code>cdr</code></li>
<li><code>cond</code> / <code>else</code></li>
<li><code>cons</code></li>
<li><code>equal?</code></li>
<li><code>lambda</code></li>
<li><code>let*</code></li>
<li><code>list?</code></li>
<li><code>quote</code></li>
</ul>

<p>For the precise meanings of each of these forms,
please refer to the Revised<sup>5</sup> Report on the Algorithmic Language Scheme.</p>

<p>Pixley only understands the Scheme datatypes of lists, symbols, function values (lambdas),
and booleans.  Pixley's behaviour regarding any attempt to produce a value of any other type is undefined.
Neither is its behaviour defined for s-expressions which result in errors
when evaluated as Scheme programs.</p>

<h2>Syntax</h2>

<p>Pixley's syntax is a strict subset of Scheme's.  The meanings of
syntactical constructs which are valid in Scheme but not defined in Pixley (such as
numbers, strings, comments, quasiquoting, or hygienic macros) are undefined.</p>

<p>Of literal values, only those of list type can be directly introduced through syntactical
elements.  Like Scheme, a literal null list can be denoted by <code>(quote ())</code>.
(However, <code>()</code> by itself is considered to be an illegal, empty application.)
Literal symbols may be introduced through the <code>quote</code> form,
literal function values can be produced through the <code>lambda</code>
form, and the two boolean values can be produced through the use of trivial
tests such as <code>(equal? (quote ()) (quote ()))</code>
and <code>(equal? (quote a) (quote b))</code>.</p>

<h2>Reference Implementation</h2>

<p>The reference implementation of Pixley, <code>pixley.pix</code>,
is written in 122 lines of Pixley (or, if you prefer, 122 lines of Scheme;
and if you prefer more Scheme-ly metrics, it consists of 405 instances of
53 unique symbols in 668 cons cells.)</p>

<p><code>pixley.pix</code> does not include a lexical processor:
the Pixley program to be interpreted
must be made available to the interpreter as a native s-expression.
Since Pixley does not implement <code>define</code>, this is
usually achieved by applying a textual copy of <code>pixley.pix</code>
(a <code>lambda</code> expression)
to the s-expression to be interpreted as a Pixley program.</p>

<p>Because <code>pixley.pix</code> is written in Pixley, multiple
copies can be applied successively with equivalent semantics.
For example, having <code>pixley.pix</code> interpret some
program <code>foo.pix</code> should produce the same
observable behaviour (modulo performance) as having
<code>pixley.pix</code> interpret <code>pixley.pix</code> interpreting
<code>foo.pix</code>, or having
<code>pixley.pix</code> interpret <code>pixley.pix</code>
interpret <code>pixley.pix</code> interpreting
<code>foo.pix</code>, etc. etc. ad infinitum.
The Scheme test suite for the Pixley reference interpreter does just that,
running through the set of tests at successively higher "degrees".
This is an example of a <dfn>computational automorphism</dfn>
and is a property of any bootstrapped universal computer (or rather,
of the Turing-complete language of that computer.)</p>

<p>The Pixley reference interpreter is highly meta-circular,
implementing e.g. Pixley's <code>car</code> simply in terms of the
underlying Pixley (or Scheme) <code>car</code>.  The datatypes of
Pixley are likewise directly represented by the corresponding datatypes
in the underlying language.
Environments are represented as lists similar to association lists,
except containing two-element sublists instead of pairs, because Pixley
can't directly represent pairs.  Each sublist's first element is a symbol
naming the identifier, and the second is the value to which it is bound.</p>

<h2>History</h2>

<h3>Pixley 1.0</h3>

<p>Pixley 1.0 was released on May 1<sup>st</sup>, 2009, from Cupertino,
California.</p>

<p>In addition to the 10 Scheme symbols listed above, Pixley 1.0 (and 1.1) also implemented
the Scheme functions <code>cadr</code> and <code>null?</code>. However, it was
found that the interpreter was actually shorter if those functions were defined
only locally within the interpreter.  They were thus removed from the Pixley
language in version 2.0.  It is easy enough to apply the same technique to any
Pixley 1.0 (or 1.1) program to convert it to Pixley 2.0; simply wrap it in the following:</p>

<pre>
(let* ((cadr (lambda (alist)
         (car (cdr alist))))
       (null? (lambda (expr)
         (equal? expr (quote ())))))
  ...)
</pre>

<h3>Pixley v1.1</h3>

<p>Pixley 1.1 was released on November 5<sup>th</sup>, 2010, from Evanston,
Illinois.</p>

<p>Funny story!  So I was writing writing stuff in C to compile with DICE C for AmigaOS 1.3, right?
And I was looking for something to write, and I decided to implement Pixley in C.
And that was going pretty well; as I was implementing each command, I was making up
ad-hoc test cases for it, and I was thinking "Hey, I should record these somewhere and make a test
suite for the Pixley reference distribution!"  Of course, I never did record those cases, but
in the following weeks I started doing various other things with the Pixley project, and
at one point, decided anew that it would be a good idea to bulk up the test cases.</p>

<p>So I started writing more test cases, right?  And I got to testing <code>list?</code>.
Well, <code>(list? (lambda (x) x))</code> should be <em>false</em>, right?  Sure.
Except it wasn't.</p>

<p>Well, I went to the docs and saw that there was an easy explanation for this.  This was
for Pixley 1.0, mind you, and they've changed since then, but they told me that:</p>

<blockquote>
<p>Some places where the underlying and interpreted representations must
differ are in the data types, namely lists and lambda functions.</p>

<p>Each interpreted list is represented as a two-element underlying list.  The
first element is the atom <code>__list__</code> and the second
element is the (interpreted) list itself.</p>

<p>Each interpreted lambda function is represented by an underlying list
of four elements: the atom <code>__lambda__</code>,
a representation of the enclosing environment, a list of the formal
arguments of the function, and the (interpreted) body of the function.</p>
</blockquote>

<p>In other words, in the
reference interpreter, both lists and function values are represented with lists; you tell
them apart by looking at the first element, which is <code>__lambda__</code> for a
function value and <code>__list__</code> for a list.  And <code>list?</code> was
probably just looking at the representation list and not checking the first element,
right?  Sure.  Except, no, it was much more.</p>

<p>It turns out that while function values were in fact represented by lists
with <code>__lambda__</code> as the first element, lists were just represented by lists.
Which means that there was an overlap between the types: a function value was, at the Pixley
level, a kind of list, and could be treated just like one, for example with <code>car</code>
and <code>cdr</code>.  This is clearly not kosher R<sup>5</sup>RS, which has a whole
<em>section</em> titled "Disjointness of types".  (Of course, neither "list" nor
"function value" is mentioned in that section, but I'd say the spirit of the law is pretty
clear there or whatever.)</p>

<p>So this meant I had to fix the Pixley interpreter! But first, I had to make a decision: how to
represent lists?  Well, there were two general paths here: more meta-circular, or less.
I could make the implementation conform to the documentation, making it less meta-circular,
but then I'd have to be changing everything that built (or touched) a list to build (or check
for) a list with <code>__list__</code> at its head.  Doable, but kind of distasteful.
Alternatively, I could make it more meta-circular: keep lists represented as lists, and
go one further by representing function values as function values.  This is a little unilluminating,
as it no longer lays bare how function values work; but this is made up for by the fact
that most of the mechanics have to continue to exist in the implementation (just in
different places) and there is a modest savings of space (because we can fall back on
the implementing language's semantics for cases like trying to execute a non-function.)
So that's what I did.</p>

<p>Now, this technically changed the semantics of the language, because gosh you
<em>could</em> have been relying on the fact that <code>(car (lambda (x) x))</code>
evaluates to <code>__lambda__</code>, in your Pixley programs, and we can't have that,
can we?  So the language version was bumped up to 1.1.</p>

<h4>Goodies</h4>

<p>The Pixley 1.1 distribution also included the following supplementary material.</p>

<ul>
<li>An enlarged test suite (previously mentioned).</li>
<li>A REPL (read-eval-print loop, or "interactive mode" interpreter), written in Scheme.</li>
<li>A statistics generator, written in Scheme, which counts the cons cells, symbol
instances, and unique symbols present in a given s-expression.  This was to measure the
complexity of the Pixley interpreter.</li>
<li>A Mini-Scheme driver.  During my adventures in getting programs
to run under AmigaOS 1.3, I compiled Mini-Scheme thereunder, and got Pixley to run
under it by including the Pixley interpreter in Mini-Scheme's <code>init.scm</code> file and
<code>eval</code>'ing it therein.  From this I conclude that, although I have not confirmed
this is in a solid way by looking at the spec or anything, Pixley is also a strict subset of
R<sup>4</sup>RS Scheme.</li>
</ul>

<h3>Pixley 2.0</h3>

<p>A previously mentioned, Pixley 2.0 removes the <code>cadr</code> and <code>null?</code>
functions from the language.</p>

<h4>Goodies</h4>

<p>The Pixley 2.0 distribution also includes the following supplementary material.</p>

<ul>
<li>Bourne Shell scripts to run Pixley programs which are stored in individual files.
<code>pixley.sh</code> runs either a self-contained Pixley program from a single file,
or evaluates a Pixley file to a function value and applies it to an S-expression stored in a
second file.  <code>scheme.sh</code> does the same thing, but with Scheme, as a
sanity-check.  By default these scripts use <code>plt-r5rs</code> for the Scheme interpreter,
but that can be changed with an environment variable.</li>
<li>A P-Normalizer written in Pixley, probably the first non-trivial Pixley program
to be written, aside from the Pixley interpreter itself.  P-Normal Pixley is a simplified version of
Pixley where <code>let*</code> and <code>cond</code> only handle a single instance
of what they do (like <code>let</code> and <code>if</code> in Scheme.)  This form is
described more fully in the <a href="../eg/p-normal.falderal">Falderal literate test
suite for the P-Normalizer</a>.</li>
<li>Test suites, written in Falderal, for both Pixley and the P-Normalizer.  The
original test suite written in Scheme, which runs successively deeper nested copies of
the Pixley interpreter, is still included in the distribution.</li>
<li>A few other standalone Pixley examples, including <code>reverse.pix</code>,
which reverses the given list.</li>
</ul>

<h2>Conclusion</h2>

<p>The last main division of a discourse,
usually containing a summing up of the points
and a statement of opinion or decisions reached.</p>

<p>Keep Smiling!  (I could never stand those "Home Sweet Home" folks.)
<br/>Chris Pressey
<br/>December 9<sup>th</sup>, 2011
<br/>Evanston, Illinois</p>

</body>
</html>
