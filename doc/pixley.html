<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/2002/REC-xhtml1-20020801/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
<title>The Pixley Programming Language</title>
  <!-- begin html doc dynamic markup -->
  <script type="text/javascript" src="/contrib/jquery-1.6.4.min.js"></script>
  <script type="text/javascript" src="/scripts/documentation.js"></script>
  <!-- end html doc dynamic markup -->
</head>
<body>

<h1>The Pixley Programming Language</h1>

<p>Language version 2.0</p>

<h2>Introduction</h2>

<p><dfn>Pixley</dfn> is a strict and purely functional subset of R<sup>5</sup>RS Scheme.
All Pixley programs are also therefore Scheme programs.</p>

<p>Pixley was designed for "bootstrappability".  I aimed to encompass a
minimal subset of Scheme that was still expressive enough to
permit writing a Pixley interpreter without too much pain.</p>

<h2>Semantics</h2>

<p>Pixley implements the following functions and forms from Scheme
(listed in alphabetical order:)</p>

<ul>
<li><code>car</code></li>
<li><code>cdr</code></li>
<li><code>cond</code> / <code>else</code></li>
<li><code>cons</code></li>
<li><code>equal?</code></li>
<li><code>lambda</code></li>
<li><code>let*</code></li>
<li><code>list?</code></li>
<li><code>quote</code></li>
</ul>

<p>For the precise meanings of each of these forms,
please refer to the Revised<sup>5</sup> Report on the Algorithmic Language Scheme.</p>

<p>Pixley 1.0 also implemented the Scheme functions <code>cadr</code> and <code>null?</code>,
however, it was found that the interpreter was shorter if those functions were defined
only locally within the interpreter, and not made a part of the language.  It is easy enough
to do the same thing to any Pixley 1.0 program; to convert it to Pixley 2.0, simply wrap it
in the following:</p>

<pre>
(let* ((cadr (lambda (alist)
         (car (cdr alist))))
       (null? (lambda (expr)
         (equal? expr (quote ())))))
  ...)
</pre>

<p>Pixley only understands the Scheme datatypes of lists, symbols, function values (lambdas),
and booleans.  Pixley's behaviour regarding any attempt to produce a value of any other type is undefined.
Neither is its behaviour defined for s-expressions which result in errors
when evaluated as Scheme programs.</p>

<h2>Syntax</h2>

<p>Pixley's syntax is identical to Scheme's.  The meanings of
syntactical constructs which are valid in Scheme but not defined in Pixley (such as
numbers, strings, comments, quasiquoting, or hygienic macros) are undefined.</p>

<p>Of literal values, only those of list type can be directly introduced through syntactical
elements.  Like Scheme, a literal null list can be denoted by <code>(quote ())</code>.
(However, <code>()</code> by itself is considered to be an illegal, empty application.)
Literal symbols may be introduced through the <code>quote</code> form,
literal function values can be produced through the <code>lambda</code>
form, and the two boolean values can be produced through the use of trivial
tests such as <code>(equal? (quote ()) (quote ()))</code>
and <code>(equal? (quote a) (quote b))</code>.</p>

<h2>Reference Implementation</h2>

<p>The reference implementation of Pixley, <code>pixley.pix</code>,
is written in 124 lines of Pixley (or, if you prefer, 124 lines of Scheme;
and if you prefer more Scheme-ly metrics, it consists of 407 instances of
53 unique symbols in 672 cons cells.)</p>

<p><code>pixley.pix</code> does not include a lexical processor:
the Pixley program to be interpreted
must be made available to the interpreter as a native s-expression.
Since Pixley does not implement <code>define</code>, this is
usually achieved by applying a textual copy of <code>pixley.pix</code>
(a <code>lambda</code> expression)
to the s-expression to be interpreted as a Pixley program.</p>

<p>Because <code>pixley.pix</code> is written in Pixley, multiple
copies can be applied successively with equivalent semantics.
For example, having <code>pixley.pix</code> interpret some
program <code>foo.pix</code> should produce the same
observable behaviour (modulo performance) as having
<code>pixley.pix</code> interpret <code>pixley.pix</code> interpreting
<code>foo.pix</code>, or having
<code>pixley.pix</code> interpret <code>pixley.pix</code>
interpret <code>pixley.pix</code> interpreting
<code>foo.pix</code>, etc. etc. ad infinitum.</p>

<p>The unit tests for the Pixley reference interpreter do just that,
running through the set of tests at successively higher "degrees".
This is an example of a <dfn>computational automorphism</dfn>
and is a property of any bootstrapped universal computer (or rather,
of the Turing-complete language of that computer.)</p>

<p>The Pixley reference interpreter is highly meta-circular,
implementing e.g. Pixley's <code>car</code> simply in terms of the
underlying Pixley (or Scheme) <code>car</code>.
Some places where the underlying and interpreted representations must
differ are in the data types, namely lists and lambda functions.</p>

<p>Each interpreted list is represented as a two-element underlying list.  The
first element is the atom <code>__list__</code> and the second
element is the (interpreted) list itself.  (<em>Note (Nov 2010): this is a total lie.
the Interlude, below, for the truth.</em>)</p>

<p>Each interpreted lambda function is represented by an underlying list
of four elements: the atom <code>__lambda__</code>,
a representation of the enclosing environment, a list of the formal
arguments of the function, and the (interpreted) body of the function.
Environments are represented as lists of two-element sublists, where
each sublist's first element is a symbol naming the identifier and the
second is a term giving the value.</p>

<h2>Interlude: Pixley v1.1</h2>

<p>So I was writing writing stuff in C to compile with DICE C for AmigaOS 1.3, right?
And I was looking for something to write, and I decided to implement Pixley in C.
And that was going pretty well; as I was implementing each command, I was making up
ad-hoc test cases for it, and I was thinking "Hey, I should record these somewhere and make a test
suite for the Pixley reference distribution!"  Of course, I never did record those cases, but
in the following weeks I started doing various other things with the Pixley project, and
at one point, decided anew that it would be a good idea to bulk up the test cases.</p>

<p>So I started writing more test cases, right?  And I got to testing <code>list?</code>.
Well, <code>(list? (lambda (x) x))</code> should be <em>false</em>, right?  Sure.
Except it wasn't.</p>

<p>Well, I went to the docs and saw that there was an easy explanation for this: in the
reference interpreter, both lists and function values are represented with lists; you tell
them apart by looking at the first element, which is <code>__lambda__</code> for a
function value and <code>__list__</code> for a list.  And <code>list?</code> was
probably just looking at the representation list and not checking the first element,
right?  Sure.  Except, no, it was much more.</p>

<p>It turns out that while function values are in fact represented by lists
with <code>__lambda__</code> as the first element, lists are just represented by lists.
Which means that there is an overlap between the types: a function value is, at the Pixley
level, a kind of list, and can be treated just like one, for example with <code>car</code>
and <code>cdr</code>.  This is clearly not kosher R<sup>5</sup>RS, which has a whole
<em>section</em> titled "Disjointness of types".  (Of course, neither "list" nor
"function value" is mentioned in that section, but I'd say the spirit of the law is pretty
clear there or whatever.)</p>

<p>So this means I had to fix Pixley!  And that's what stands before you (bundled with
the fattened test suite previously mentioned, a REPL, an implementation harness for
Mini-Scheme, and a statistics generator.)  But first, I had to make a decision: how to
represent lists?</p>

<p>Well, there were two general paths here: more meta-circular, or less.  I could
make the implementation conform to the documentation, making it less meta-circular,
but then I'd have to be changing everything that built or touched a list to build or check
for a list with <code>__list__</code> at its head.  Doable, but kind of distasteful.
Alternatively, I could make it more meta-circular: keep lists represented as lists, and
go one further by representing function values as function values.  This is a little unilluminating,
as it no longer lays bare how function values work; but this is made up for by the fact
that most of the mechanics have to continue to exist in the implementation (just in
different places) and there is a modest savings of space (because we can fall back on
the implementing language's semantics for cases like trying to execute a non-function.)
So that's what I did.</p>

<p>Now, this technically changes the semantics of the language, because gosh you
<em>could</em> have been relying on the fact that <code>(car (lambda (x) x))</code>
evaluates to <code>__lambda__</code>, in your Pixley programs, and we can't have that,
can we?  So the language version has been bumped up to 1.1.</p>

<p>One other thing deserves to be mentioned.  During my adventures in getting programs
to run under AmigaOS 1.3, I compiled Mini-Scheme thereunder, and got Pixley to run
under it by including the Pixley interpreter in Mini-Scheme's <code>init.scm</code> file and
<code>eval</code>'ing it therein.  From this I conclude that, although I have not confirmed
this is in a solid way by looking at the spec or anything, Pixley is also a strict subset of
R<sup>4</sup>RS Scheme.</p>

<h2>Conclusion</h2>

<p>The last main division of a discourse,
usually containing a summing up of the points
and a statement of opinion or decisions reached.</p>

<p>Keep Smiling!  (I could never stand those "Home Sweet Home" folks.)
<br/>Chris Pressey
<br/>May 1<sup>st</sup>, 2009
<br/>Cupertino, California, USA</p>

</body>
</html>
